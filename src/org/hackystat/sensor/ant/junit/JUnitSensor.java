package org.hackystat.sensor.ant.junit;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DirectoryScanner;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.Task;
import org.apache.tools.ant.types.FileSet;
import org.hackystat.core.kernel.admin.SensorProperties;
import org.hackystat.core.kernel.sensordata.SensorDataPropertyMap;
import org.hackystat.core.kernel.shell.SensorShell;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;


/**
 * Implements an Ant task that parses the XML files generated by JUnit
 * and sends the test case results to the Hackystat server.
 *
 * @author Philip Johnson, Hongbing Kou, Joy Agustin
 * @version $Id: JUnitSensor.java,v 1.1.1.1 2005/10/20 23:56:58 johnson Exp $
 */
public class JUnitSensor extends Task {

  /**  The list of all XML filesets generated by the junit task. */
  private ArrayList filesets;

  /** Whether the user has enabled this sensor in their properties file. */
  private boolean isEnabled = false;

  /** Whether or not to print out messages during JUnit send. */
  private boolean verbose = false;

  /** The sensor shell instance used by this sensor. */
  private SensorShell shell;
  
  /** Root of the source path, e.g. C:/svn/hackystat/hackySensor_JUnit. */ 
  private String sourcePath;
  
  /**  Initialize a new instance of a JUnitSensor. */
  public JUnitSensor() {
    this.filesets = new ArrayList();
    SensorProperties sensorProps = new SensorProperties("JUnit");
    this.shell = new SensorShell(sensorProps, false, "junit");
    this.isEnabled = sensorProps.isSensorEnabled();
    // Set the tool for UnitTest commands in this sensor to "JUnit".
    String[] toolArgs = {"set", "tool=JUnit"};
    this.shell.doCommand(new Date(), "UnitTest", Arrays.asList(toolArgs));
  }

  /**
   * Set the verbose attribute to "on", "true", or "yes" to enable trace messages
   * while the JUnit sensor is running.
   *
   * @param mode The new verbose value: should be "on", "true", or "yes" to enable.
   */
  public void setVerbose(String mode) {
    this.verbose = Project.toBoolean(mode);
  }

  /**
   * Sets source path of the root. 
   * 
   * @param sourcePath Source file path.
   */
  public void setSourcePath(String sourcePath) {
    File sourcePathFile = new File(sourcePath);
    try {
      this.sourcePath = sourcePathFile.getCanonicalPath();  
    }
    catch (IOException e) {
      // Invalid path
      this.sourcePath = null;
    }    
  }
  
  /**
   * Initialize a new instance of a JUnitSensor, passing the host and
   * directory key in explicitly. This supports testing. Note that when
   * this constructor is called, offline data recovery by the sensor is disabled.
   *
   * @param host The hackystat host URL.
   * @param dirKey The user's 12 character key.
   */
  public JUnitSensor(String host, String dirKey) {
    this.filesets = new ArrayList();
    SensorProperties sensorProps = new SensorProperties(host, dirKey);
    this.shell = new SensorShell(sensorProps, false, "test", false);
  }

  /**
   *  Parses the JUnit XML files and sends the resulting JUnit test case results to
   *  the hackystat server.  This method is invoked automatically by Ant.
   *
   * @throws BuildException If there is an error.
   */
  public void execute() throws BuildException {
    int numberOfTests = 0;
    // Return without sending data if the sensor is disabled.
    if (!this.isEnabled) {
      if (this.verbose) {
        System.out.println("JUnitSensor disabled; no data sent.");
      }
      return;
    }
    // If verbose mode, echo settings now.
    if (this.verbose) {
      System.out.println("Sensor enabled?: " + this.isEnabled);
    }

    Date startTime = new Date();
    try {
      // Get the file names from the FileSet directives.
      ArrayList files = getFiles();

      // Iterate though each file, extract the JUnit data, send to sensorshell.
      for (Iterator i = files.iterator(); i.hasNext();) {
        // get full path of next file to process
        String junitXmlFile = ((File) i.next()).getPath();
        if (this.verbose) {
          System.out.println("Processing file: " + junitXmlFile);
        }
        numberOfTests += processJunitXmlFile(junitXmlFile);
      }

      if (send()) {
        Date endTime = new Date();
        long elapsedTime = (endTime.getTime() - startTime.getTime()) / 1000;
        System.out.println("Hackystat data on " + numberOfTests + " JUnit tests sent to " 
                            + shell.getSensorProperties().getHackystatHost() 
                            + " (" + elapsedTime + " secs.)");
      }
      else {
        System.out.println("Failed to send Hackystat JUnit test data. See log for details.");
      }
    }
    catch (Exception e) {
      throw new BuildException("Errors occurred while processing the junit report file " + e);
    }
    finally { // After send-out, close the sensor shell.
      this.shell.close();
    }
  }

  /**
   * Sends any accumulated data in the SensorShell to the server.
   *
   * @return True if the data was sent successfully.
   */
  public boolean send() {
    return this.shell.send();
  }

  /**
   * Parses a JUnit XML file and sends the JUnitEntry instances to the shell.
   *
   * @param fileNameString The XML file name to be processed.
   * @exception JUnitSensorException if any error.
   * @return The number of test cases in this XML file.
   */
  public int processJunitXmlFile(String fileNameString) throws JUnitSensorException {
    try {
      // Build the XML document object using JDOM.
      SAXBuilder builder = new SAXBuilder();
      File xmlFile = new File(fileNameString);
      Document doc = builder.build(xmlFile);
      Element testsuite = doc.getRootElement();

      // The testClassName is constant for all of the actual test case instances.
      String testClassName = testsuite.getAttribute("name").getValue();

      // The start time for all entries will be approximated by the XML file's last mod time.
      // The shell will ensure that it's unique by tweaking the millisecond field.
      long startTime = xmlFile.lastModified();

      // Iterate through testcase XML node, build a UnitTest, and add it.
      List testCaseNodes = testsuite.getChildren("testcase");
      for (Iterator i = testCaseNodes.iterator(); i.hasNext();) {
        // We already have testClassName and startTime.
        Element testCase = (Element) i.next();
        String testCaseName = testCase.getAttribute("name").getValue();

        // Get the stop time
        double elapsedTime = Double.parseDouble(testCase.getAttribute("time").getValue());
        long elapsedTimeMillis = (long) (elapsedTime * 1000);
        String elapsedTimeString = new Long(elapsedTimeMillis).toString();
        
        // Make a list of error strings.
        // This should always be a list of zero or one elements.
        List xmlErrorsList = testCase.getChildren("error");
        List stringErrorList = new ArrayList();
        for (Iterator j = xmlErrorsList.iterator(); j.hasNext();) {
          Element error = (Element) j.next();
          String errorMsg = error.getText();
          stringErrorList.add(errorMsg);
        }

        // Make a list of failure strings.
        // This should always be a list of zero or one elements.
        List xmlFailuresList = testCase.getChildren("failure");
        List stringFailureList = new ArrayList();
        for (Iterator j = xmlFailuresList.iterator(); j.hasNext();) {
          Element failure = (Element) j.next();
          String failureMsg = failure.getText();
          stringFailureList.add(failureMsg);
        }

        String result = "pass";
        if (stringErrorList.size() > 0 || stringFailureList.size() > 0) {
          result = "fail";
        }
        
        // Create the args to the SensorShell UnitTest command.
        List argList = new ArrayList();
        argList.add("add");
        
        String name = testClassName + "." + testCaseName; 
        argList.add("name=" + name);
        argList.add("path=" + testCaset2Path(testClassName));
        argList.add("result=" + result);
        
        // Put the rest value in optional pMap field. 
        SensorDataPropertyMap pMap = new SensorDataPropertyMap();
        pMap.put("elapsedTime", elapsedTimeString);
        
        if (stringFailureList.size() > 0) {
          pMap.put("failureString", (String) stringFailureList.get(0));
        }
        else if (stringErrorList.size() > 0) {
          //argList.add(" ");  // Not sure why this was in here during BOA parsing.
          pMap.put("errorString", (String) stringErrorList.get(0));
        }
        pMap.put("testName", testClassName);
        pMap.put("testCase", testCaseName);        
        
        // Adds pMap data. 
        argList.add("pMap=" + pMap.encode());
        
        // Alter startTime to guarantee uniqueness.
        long tweakedStartTime = startTime + computeFileHash(name);
        this.shell.doCommand(new Date(tweakedStartTime), "UnitTest", argList);
      }
      return testCaseNodes.size();
    }
    catch (Exception e) {
      e.printStackTrace();
      throw new JUnitSensorException("Failed to process " + fileNameString + "   " + e);
    }
  }

  /**
   * Makes of file name path from source path directory and full-qualified test case name. 
   * 
   * @param testCaseName Dot delimited testcase name.
   * @return Source of testcase name.
   */
  private String testCaset2Path(String testCaseName) {
    String path = this.sourcePath == null ? "" : this.sourcePath;
    if (path.length() > 0 && !path.endsWith("/")) {
      path += File.separator;
    }
    
    // Replace dot delimiters with slash.
    StringBuffer subPath = new StringBuffer();
    String[] fragments = testCaseName.split("\\.");
    for (int i = 0; i < fragments.length; i++) {
      subPath.append(fragments[i]);
      if (i < fragments.length - 1) {
        subPath.append(File.separator);
      }
    }
    // JUnit sensor is applicable on java file only
    subPath.append(".java");
    return path + subPath;
  }
  
  /**
   *  Add a fileset which contains the junit report xml file to be processed.
   *  Invoked automatically by Ant.
   *
   * @param fs The new fileset of xml results.
   */
  public void addFileSet(FileSet fs) {
    filesets.add(fs);
  }

  /**
   *  Get all of the files in the fileset.
   *
   * @return All files in the fileset.
   */
  private ArrayList getFiles() {
    ArrayList fileList = new ArrayList();
    final int size = filesets.size();
    for (int i = 0; i < size; i++) {
      FileSet fs = (FileSet) filesets.get(i);
      DirectoryScanner ds = fs.getDirectoryScanner(getProject());
      ds.scan();
      String[] f = ds.getIncludedFiles();

      for (int j = 0; j < f.length; j++) {
        String pathname = f[j];
        File file = new File(ds.getBasedir(), pathname);
        file = getProject().resolveFile(file.getPath());
        fileList.add(file);
      }
    }
    return fileList;
  }

  /**
   * Computes a long value from the passed String.  Equal strings will always
   * compute the same long value and unequal strings will (usually) compute a different
   * long value.  This value is added on to the startTime associated with that TestClass (which
   * is itself determined by the file's last mod date.
   * The value computed generally varies between 70,000 and 250,000 (i.e. 70 and 250 seconds). This
   * hash is used to solve the problem of multiple files with the same last mod time being sent
   * by different sensor shell instances (which results in clobbering of the data on the server
   * side.)
   *
   * @param name The name of the test class whose hash is to be computed.
   * @return A hash value (generally between about 70,000 and 250,000).
   */
  private long computeFileHash(String name) {
    long hash = 0;
    for (int i = 0; i < name.length(); i++) {
      hash += (name.charAt(i) * i);
    }
    return hash;
  }
}