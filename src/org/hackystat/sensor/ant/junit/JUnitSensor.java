package org.hackystat.sensor.ant.junit;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import javax.xml.datatype.XMLGregorianCalendar;

import org.apache.tools.ant.BuildException;
import org.hackystat.sensor.ant.junit.resource.jaxb.Error;
import org.hackystat.sensor.ant.junit.resource.jaxb.Failure;
import org.hackystat.sensor.ant.junit.resource.jaxb.Testcase;
import org.hackystat.sensor.ant.junit.resource.jaxb.Testsuite;
import org.hackystat.sensor.ant.task.HackystatSensorTask;
import org.hackystat.sensor.ant.util.LongTimeConverter;
import org.hackystat.sensorshell.SensorShellException;


/**
 * Implements an Ant task that parses the XML files generated by JUnit and sends the test case
 * results to the Hackystat server.
 * 
 * @author Philip Johnson, Hongbing Kou, Joy Agustin, Julie Ann Sakuda, Aaron A. Kagawa
 */
public class JUnitSensor extends HackystatSensorTask {

  /** Root of the source path, e.g. C:/svn/hackystat/hackySensor_JUnit. */
  private String sourcePath;

  /** The name of this tool. */
  private static String tool = "JUnit";

  /** Initialize a new instance of a JUnitSensor. */
  public JUnitSensor() {
    super(tool);
  }
  
  /**
   * Initialize a new instance of a JUnitSensor, passing the host email, and password directly. This
   * supports testing. Note that when this constructor is called, offline data recovery by the
   * sensor is disabled.
   * 
   * @param host The hackystat host URL.
   * @param email The Hackystat email to use.
   * @param password The Hackystat password to use.
   */
  public JUnitSensor(String host, String email, String password) {
    super(host, email, password, tool);
  }

  /**
   * Sets source path of the root.
   * 
   * @param sourcePath Source file path.
   */
  public void setSourcePath(String sourcePath) {
    File sourcePathFile = new File(sourcePath);
    try {
      this.sourcePath = sourcePathFile.getCanonicalPath();
    }
    catch (IOException e) {
      throw new BuildException("Could not find sourcePath: " + sourcePath, e);
    }
  }


  /**
   * Parses the JUnit XML files and sends the resulting JUnit test case results to the hackystat
   * server. This method is invoked automatically by Ant.
   * 
   * @throws BuildException If there is an error.
   */
  @Override
  public void execute() throws BuildException {
    setupSensorShell();

    int numberOfTests = 0;

    Date startTime = new Date();
    try {
      // Get the file names from the FileSet directives.
      ArrayList<File> files = getFiles();

      // Iterate though each file, extract the JUnit data, send to sensorshell.
      for (Iterator<File> i = files.iterator(); i.hasNext();) {
        // get full path of next file to process
        String junitXmlFile = i.next().getPath();
        verboseInfo("Processing file: " + junitXmlFile);
        numberOfTests += processJunitXmlFile(junitXmlFile);
      }

      if (send() > 0) {
        Date endTime = new Date();
        long elapsedTime = (endTime.getTime() - startTime.getTime()) / 1000;
        info("Hackystat data on " + numberOfTests + " JUnit tests sent to "
              + this.sensorProps.getSensorBaseHost() + " (" + elapsedTime + " secs.)");
      }
      else if (numberOfTests == 0) {
        info("No data to send.");
      }
      else {
        info("Failed to send Hackystat JUnit test data.");
      }
    }
    catch (Exception e) {
      throw new BuildException(errMsgPrefix + "Errors occurred while processing junit files.", e);
    }
    finally { // After send-out, close the sensor shell.
      this.sensorShell.quit();
    }
  }


  /**
   * Parses a JUnit XML file and sends the JUnitEntry instances to the shell.
   * 
   * @param fileNameString The XML file name to be processed.
   * @exception BuildException if any error.
   * @return The number of test cases in this XML file.
   */
  public int processJunitXmlFile(String fileNameString) throws BuildException {
    XMLGregorianCalendar runtimeGregorian = LongTimeConverter.convertLongToGregorian(this.runtime);
    File xmlFile = new File(fileNameString);

    try {
      JAXBContext context = JAXBContext
          .newInstance(org.hackystat.sensor.ant.junit.resource.jaxb.ObjectFactory.class);
      Unmarshaller unmarshaller = context.createUnmarshaller();

      // One JUnit test suite per file
      Testsuite suite = (Testsuite) unmarshaller.unmarshal(xmlFile);

      String testClassName = suite.getName();
      // The start time for all entries will be approximated by the XML file's last mod time.
      // The shell will ensure that it's unique by tweaking the millisecond field.
      long startTime = xmlFile.lastModified();

      List<Testcase> testcases = suite.getTestcase();
      for (Testcase testcase : testcases) {
        // Test case name
        String testCaseName = testcase.getName();

        // Get the stop time
        double elapsedTime = testcase.getTime();
        long elapsedTimeMillis = (long) (elapsedTime * 1000);

        // Make a list of error strings.
        // This should always be a list of zero or one elements.
        List<String> stringErrorList = new ArrayList<String>();
        Error error = testcase.getError();
        if (error != null) {
          stringErrorList.add(error.getMessage());
        }

        // Make a list of failure strings.
        // This should always be a list of zero or one elements.
        List<String> stringFailureList = new ArrayList<String>();
        Failure failure = testcase.getFailure();
        if (failure != null) {
          stringFailureList.add(failure.getMessage());
        }

        String result = "pass";
        if (!stringErrorList.isEmpty() || !stringFailureList.isEmpty()) {
          result = "fail";
        }

        String name = testClassName + "." + testCaseName;
        // Alter startTime to guarantee uniqueness.
        long uniqueTstamp = this.tstampSet.getUniqueTstamp(startTime);

        // Get altered start time as XMLGregorianCalendar
        XMLGregorianCalendar startTimeGregorian = LongTimeConverter
            .convertLongToGregorian(uniqueTstamp);

        Map<String, String> keyValMap = new HashMap<String, String>();
        keyValMap.put("Tool", "JUnit");
        keyValMap.put("SensorDataType", "UnitTest");

        // Required
        keyValMap.put("Runtime", runtimeGregorian.toString());
        keyValMap.put("Timestamp", startTimeGregorian.toString());
        keyValMap.put("Name", name);
        keyValMap.put("Resource", testCaseToPath(testClassName));
        keyValMap.put("Result", result);

        // Optional
        keyValMap.put("ElapsedTime", Long.toString(elapsedTimeMillis));
        keyValMap.put("TestName", testClassName);
        keyValMap.put("TestCaseName", testCaseName);

        if (!stringFailureList.isEmpty()) {
          keyValMap.put("FailureString", stringFailureList.get(0));
        }

        if (!stringErrorList.isEmpty()) {
          keyValMap.put("ErrorString", stringErrorList.get(0));
        }

        this.sensorShell.add(keyValMap); // add data to sensorshell
      }
      return testcases.size();
    }
    catch (JAXBException e) {
      throw new BuildException(errMsgPrefix + "Failure in JAXB " + fileNameString, e);
    }
    catch (SensorShellException f) {
      throw new BuildException(errMsgPrefix + "Failure in SensorShell " + fileNameString, f);
    }
  }

  /**
   * Makes of file name path from source path directory and fully-qualified test case name.
   * 
   * @param testCaseName Dot delimited test case name.
   * @return Source of test case name.
   */
  private String testCaseToPath(String testCaseName) {
    String path = this.sourcePath == null ? "" : this.sourcePath;
    if (path.length() > 0 && !path.endsWith("/")) {
      path += File.separator;
    }

    // Replace dot delimiters with slash.
    StringBuffer subPath = new StringBuffer();
    String[] fragments = testCaseName.split("\\.");
    for (int i = 0; i < fragments.length; i++) {
      subPath.append(fragments[i]);
      if (i < fragments.length - 1) {
        subPath.append(File.separator);
      }
    }
    // JUnit sensor is applicable on java file only
    subPath.append(".java");
    return path + subPath;
  }
}